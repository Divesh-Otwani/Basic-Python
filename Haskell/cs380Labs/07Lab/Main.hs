{-

CS 380 Lab #7
Prof. Richard Eisenberg
Spring 2017
Practical Haskell

    Write a Haskell program that loops, asking the user for a number and then reporting the numberâ€™s prime factors. Exit when the user enters in something other than a positive number.

    Implement the following utilities in Haskell:

    cat
    echo
    ls, with its -F option
    cp

    (Challenge) Ponder how to take your solution to (1) and add fancy types to it. Note that prime factorization has a simple specification: it takes a number and produces a list of numbers, each of which is prime and the product of which equals the original number. If you have your algorithm run over SNats, you should be able to create a custom list-like GADT for your output that captures these properties. You can then use such a structure to verify your algorithm.

This website is generated by Hakyll and Pandoc, both written in Haskell.


-}

module Lab7 where
import System.IO
import Data.Numbers.Primes
import Data.List
import Network.CGI.Protocol

main :: IO ()
main = do
  putStrLn "Hello, there. Welcome to lab7."
  case loop of _ -> loop


loop :: IO ()
loop = do
  putStrLn "Give me a Nat: "
  number <- getLine
  let
    c = convert number
  case c of
    Just int -> do
      putStrLn $ " The pfac is " ++ (show $ primefac int)
      loop
    Nothing -> return ()


convert s = case maybeRead s :: Maybe Integer of
  Nothing -> Nothing
  Just i -> if i > 0 then Just i else Nothing



primefac :: Integer -> [Integer]
primefac 0 = error "no prime fac of 0"
primefac n | isPrime n = [n]
           | otherwise =
             let
               firstPrime = firstprime n
               x = fst firstPrime
               xs = snd firstPrime
             in
               x : primefac xs


firstprime :: Integer -> (Integer, Integer)
firstprime n =
  let
    p = head $ dropWhile (\x -> mod n x /= 0) primes
    -- :), lazyness
    rest = div n p
  in
    (p, rest)












